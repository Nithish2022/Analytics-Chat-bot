import streamlit as st
from langchain_groq import ChatGroq
from dotenv import load_dotenv
from pandasai import Agent
import os
from streamlit_chat import message
from pandasai.responses.response_parser import ResponseParser
from PIL import Image
from PIL.Image import Image as PILImage
from typing import Union
import pandas as pd
from pandasai.connectors import PandasConnector

# Load environment variables from .env file
load_dotenv()

# Set Page config
st.set_page_config(
    layout="centered",
    initial_sidebar_state="collapsed"
)

# === INIT STATE ===
if 'dataframes' not in st.session_state:
    st.session_state['dataframes'] = None
if 'is_first_loading' not in st.session_state:
    st.session_state['is_first_loading'] = True
if "last_prompt" not in st.session_state:
    st.session_state['last_prompt'] = None
if "messages" not in st.session_state:
    st.session_state['messages'] = []
if "initial_messages_added" not in st.session_state:
    st.session_state['initial_messages_added'] = False
if 'agent' not in st.session_state:
    st.session_state['agent'] = None
if 'selected_csv' not in st.session_state:
    st.session_state['selected_csv'] = None

# === LOCAL FUNCTIONS =====
class MyStResponseParser(ResponseParser):
    def __init__(self, context) -> None:
        super().__init__(context)

    def parse(self, result):
        if isinstance(result, dict) and 'type' in result and 'value' in result:
            content_type = result['type']
            content = result['value']

            if content_type == 'plot':
                original_image = Image.open(content)
                append_messages(role="assistant", content=original_image, type=content_type)
            elif content_type == 'image':
                original_image = Image.open(content)
                append_messages(role="assistant", content=original_image, type=content_type)
            elif content_type == 'dataframe':
                append_messages(role="assistant", content=content, type=content_type)
            elif content_type == 'number':
                append_messages(role="assistant", content=str(content), type='string')
            elif content_type == 'string':
                append_messages(role="assistant", content=content, type=content_type)
            else:
                append_messages(role="assistant", content=content, type='string')
        else:
            append_messages(role="assistant", content=str(result), type='string')

def append_messages(role="user", content: Union[str, PILImage, pd.DataFrame] = "No Content", type="string"):
    msg = {"role": role, "content": content, "type": type}
    st.session_state['messages'].append(msg)
    show_message(msg)

def show_message(msg):
    message_type_to_function = {
        "dataframe": st.dataframe,
        "plot": st.image,
        "image": st.image,
        "markdown": st.markdown,
        "questions": st.button,
        "string": st.write
    }
    
    # Set the avatar based on the role
    avatar = None
    if msg['role'] == "assistant":
        avatar = 'https://is4-ssl.mzstatic.com/image/thumb/Purple113/v4/cb/49/00/cb4900e0-e38b-474c-dd29-f770b307a7f7/source/512x512bb.jpg'
    else:
        avatar = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/wcAAgAB/RecKxEAAAAASUVORK5CYII='
    
    with st.chat_message(msg['role'], avatar=avatar):
        func = message_type_to_function.get(msg['type'], st.write)
        if msg['type'] == "questions":
            questions = msg['content']
            for key, value in questions.items():
                if st.button(label=value):
                    st.session_state['question_selected'] = value
        else:
            func(msg['content'])

def initialize_agent(dataframes):
    groq_api_key = os.environ['GROQ_API_KEY']

    llm = ChatGroq(
                groq_api_key=groq_api_key, 
                model_name="llama3-70b-8192",
                temperature=0.6
                )
    description = (
            "You are a highly intelligent and user-friendly data analysis agent specializing in CNC machining data. "
            "Your primary role is to assist non-technical users in understanding and analyzing data generated by CNC machines. "
            "You simplify complex data insights, provide clear and actionable recommendations, and facilitate decision-making processes. "
            "Users can ask you questions in natural language, and you will respond with precise and informative answers. "
            "Your goal is to improve operational efficiency, predict maintenance needs, and enhance overall productivity by making data accessible and understandable. "
            "You handle tasks such as identifying machines that require maintenance, summarizing operational hours, analyzing production, "
            "and any other data-driven queries users might have about their part production. You are equipped to handle errors gracefully, "
            "provide conversational support, appropriate charts and maintain logs of interactions for continuous improvement."
            )
    field_descriptions = {
        'part_id_reference': 'Reference identifier for the part',
        'date': 'Column representing the date on which the production held',
        'shift_no': 'Represents the shift during which the production occurred',
        'machine_name': 'Name of the machine used in the production process',
        'module': 'Module of the machine production process(eg., CNC, DNC)',
        'route_card_id': 'Identifier for the part or component or route card used in the production process',
        'route_card_name': 'Name of the part or component or route card used in the production process',
        'machine_mode': 'Mode in which the machine was operating (e.g., automatic, manual)',
        'operator_no': 'Number identifying the operator who was in charge',
        'operator_name': 'Name of the operator who was in charge',
        'alarm_start_time': 'Timestamp indicating when an alarm started',
        'alarm_end_time': 'Timestamp indicating when an alarm ended',
        'alarm_duration': 'Duration of the alarm',
        'alarm_number': 'Number identifying the specific alarm',
        'alarm_message': 'Message or description of the alarm',
        'alarm_level': 'Severity level of the alarm',
        'cycle_time': 'Time taken to complete one cycle of production',
        'handling_time': 'Time taken to handle the part during production',
        'run_time': 'Total run time of the machine',
        'idle_time': 'Total idle time of the machine',
        'stop_time': 'Total stop time of the machine',
        'total_parts_target': 'Target number of parts or component or roue card or product to be produced',
        'total_parts_actual': 'Actual number of parts or component or roue card or product produced',
        'Factor': 'Factor that indicates whether the part has multipled or divided. The categorical column has values multiple or divide',
        'Factor_Value': 'Value that specifies result of part after the Factor applied on the part',
        'MTLINKi_Count': 'Count of MTLINKi, possibly a measure of communication or data transfer events',
        'efficiency': 'Efficiency of the production process',
        'targetruntime': 'Target runtime for the production process',
        'targetidletime': 'Target idle time for the production process',
        'settingtime': 'Time taken to set up the machine for production',
        'availability': 'Availability of the machine for production',
        'performance': 'Performance of the machine during production',
        'quality': 'Quality of the produced parts or component or product or route card',
        'idle_start_time': 'Timestamp indicating when the machine became idle',
        'idle_end_time': 'Timestamp indicating when the machine resumed operation',
        'idle_duration': 'Duration for which the machine was idle',
        'idle_reason': 'Reason for the machine being idle',
        'idle_reason_id': 'Identifier for the reason the machine was idle',
        'mode': 'Mode of operation (e.g., production, setting)',
        'part_start_time': 'Timestamp indicating when production of a part started',
        'part_end_time': 'Timestamp indicating when production of a part ended',
        'part_cycle_time': 'Cycle time for producing a part',
        'part_handling_time': 'Handling time for a part',
        'part_run_time': 'Run time for producing a part',
        'part_idle_time': 'Idle time during the production of a part',
        'part_count': 'Number of parts produced',
        'product_serial': 'Serial number of the produced part',
        'cumulative_id': 'Identifier for cumulative records'
        }
    
    connector = PandasConnector({"original_df": dataframes}, field_descriptions=field_descriptions)

    st.session_state['agent'] = Agent(connector,
                                      description=description, 
                                      config={"llm": llm,
                                              "conversational": True,
                                              "use_error_correction_framework": True,
                                              "response_parser": MyStResponseParser,
                                              "save_logs": True},
                                      memory_size=20)

def send_prompt(prompt):
    dataframes = st.session_state['dataframes']
    if dataframes is None:
        st.error("Dataframe is not loaded. Please check the CSV file.")
        return

    append_messages(role="user", content=prompt, type="string")
    with st.spinner("Running..."):
        try:
            # Initialize the model if not already initialized
            if st.session_state['agent'] is None:
                initialize_agent(dataframes)
    
            agent = st.session_state['agent']
            st.session_state['last_prompt'] = prompt
            agent.chat(prompt)
        except Exception as e:
            st.error(f'An error occurred: {e}')

def show_all_messages():
    messages = st.session_state['messages']
    for msg in messages:
        show_message(msg)
    return len(messages)

def main_page():
    csv_file_paths = {
        "Part": "/home/azureuser/AI/GroqMultiCSVChatPandasAI-main/GroqChatPandasAI/part1.csv",
        "Idle": "/home/azureuser/AI/GroqMultiCSVChatPandasAI-main/GroqChatPandasAI/idle1.csv",
        "Cumulative": "/home/azureuser/AI/GroqMultiCSVChatPandasAI-main/GroqChatPandasAI/cumulative1.csv",
        "Signal": "/home/azureuser/AI/GroqMultiCSVChatPandasAI-main/GroqChatPandasAI/signal1.csv",
        "Alarm": "/home/azureuser/AI/GroqMultiCSVChatPandasAI-main/GroqChatPandasAI/alarm1.csv"
    }

    selected_csv = st.sidebar.selectbox("Select Categories", list(csv_file_paths.keys()))
    
    # Reload the dataframe if a different CSV is selected
    if st.session_state['selected_csv'] != selected_csv:
        st.session_state['selected_csv'] = selected_csv
        try:
            st.session_state['dataframes'] = pd.read_csv(csv_file_paths[selected_csv])
            st.session_state['agent'] = None  # Reset the agent so it will be reinitialized
            st.session_state['messages'] = []  # Clear previous messages when a new CSV is loaded
        except Exception as e:
            st.error(f"Failed to load CSV file: {e}")
            return
    
    show_all_messages()
    if st.session_state['dataframes'] is not None:
        if st.session_state['is_first_loading']:
            if not st.session_state['initial_messages_added']:
                append_messages(role="user", content="Hey! ðŸ‘‹ ", type="string")
                append_messages(role="assistant", content="Hello! I'm your virtual assistant. I'm here to provide information about your shop floor! ðŸ¤—", type="string")
                st.session_state['initial_messages_added'] = True
            st.session_state['is_first_loading'] = False
            

    prompt = st.chat_input("Send a message")
    if prompt is not None:
        dataframes = st.session_state['dataframes']
        if dataframes is not None:
            send_prompt(prompt)
        else:
            st.error("Please upload a CSV file first.")

if __name__ == "__main__":
    main_page()
